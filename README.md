# syberryAcademy-BasicJS
##  Одно из первых заданий курса, реализовать решение перечисленных задач на JS.
# Базовый Javascript
---
### **Сосчитай котов!**

Ваша задача — сосчитать котов, спрятавшихся на заднем дворе (представленном в виде двумерного массива, `Array`). Коты прячутся хорошо, но их **ушки** (`"^^"`) видны очень хорошо. Ваша задача — реализовать функцию `countCats(backyard)`, которая сосчитает котов. Удачи!

Число найденных котов должно иметь тип `number`. Если коты не найдены, функция должна вернуть `0`.

Например:

`countCats([
    [0, 1, '^^'],
    [0, '^^', 2],
    ['^^', 1, 2]
  ]) => 3`

Решение в `src/count-cats.js`.

---
### **Углеродное датирование**

Для определения возраста археологических находок широко применяется **радиоизотопный анализ**. Один из его видов — **радиоуглеродный анализ**.

Примерный возраст образца рассчитывается при помощи измерения **соотношения** между **современной** активностью изотопа С14 и активностью этого же изотопа в **образце**.

---
<details>

  <summary>О расчетах</summary>
  Вы можете использовать формулу из статьи по ссылке выше. 0.693 — это приблизительное значение натурального логарифма двойки.

</details>

---

Ваша задача — реализовать функцию `dateSample(sampleActivity)`, которая рассчитывает примерный возраст образца (в годах). Пожалуйста, используйте данные `MODERN_ACTIVITY` и `HALF_LIFE_PERIOD`.

Параметр функции `sampleActivity` имеет тип `string`. Рассчитаный возраст образца должен иметь тип `number`. Возраст должен быть **целочисленным**. Возраст должен **округлен вверх** (при получении целого числа). В случае неправильного **типа** входного параметра или **несоответствующем** значении активности, или отсутствии аргумента функция должна вернуть `false`.

Например:

`dateSample('1') => 22387` (либо `22392`, в зависимости от используемой формулы)

`dateSample('WOOT!') => false`

Решение в `src/carbon-dating.js`.

---

### **Команда мечты**

Представьте себе, что вы с вашими друзьями решаете создать **команду мечты**. Эта команда должна иметь крутое секретное название, в котором зашифрована информация о ней. Например, это могут быть **первые буквы** имен ее членов **в верхнем регистре**, **отсортированные по алфавиту**.

Ваша задача — реализовать функцию `createDreamTeam(members)`, которая возвращает имя только что созданной команды (`string`), основанной на именах ее членов (`array`). Удачи!

Имена членов команды должны быть типа `string`. Значения другого типа должны быть **проигнорированы**. В случае неправильного **типа** аргумента `members` функция должна вернуть `false`.

NB! Имя члена команды может содержать **пробелы**.

Например:

`createDreamTeam(['Matt', 'Ann', 'Dmitry', 'Max'])` => `'ADMM'`

`createDreamTeam(['Olivia', 1111, 'Lily', 'Oscar', true, null])` => `'LOO'`

Решение в `src/dream-team.js`.

---

### **Какая пора года??**

Ваша задача — реализовать функцию `getSeason(date)`, которая принимает объект `Date` и возвращает соответствующую ему пору года. Пора года должна быть типа `string`.

---
<details>

<summary>Названия пор года в англиийском языке</summary>
В английском поры года имеют следующие наименования: весна — spring, лето — summer, осень — autumn (fall), зима — winter.

</details>

---

Если аргумент `date` не был передан, функция должна вернуть строку `'Unable to determine the time of year!'` Если аргумент `date` **некорректный**, функция должна выбросить ошибку (`Error`).
Тссс! Среди аргументов, которые попадают в эту функцию, затесался вражеский агент.
Он руководствуется знаменитой поговоркой: "Если это выглядит как **утка**, плавает как **утка**, и крякает как **утка**, тогда это, скорее всего, **утка** (и неважно, что это **на самом деле**)". Он **искусно маскируется** под настоящую дату (`date`), но умелый javascript-разработчик может поймать его и выбросить ошибку как раз вовремя!

Например:

`const springDate = new Date(2020, 02, 31)`

`getSeason(springDate) => 'spring'`

Решение в `src/what-season.js`.

---
### **Ханойская башня**

Она состоит из трех стержней и некоторого числа дисков разных размеров, которые могут быть надеты на стержень. Головоломка начинается с того, что диски расположены друг на друге, причем наименьший расположен сверху. Диски образуют конус.

Цель головоломки — переместить всю стопку на другой стержень, следуя этим простым **правилам**:
* перемещать можно только **один** диск за раз
* можно брать только **верхний** диск с одной из стопок и помещать на **верхушку** другой стопки или на пустой стержень
* диск **большего** размера нельзя класть на диск **меньшего** размера

Ваша задача значительно легче, чем придумывать алгоритм, решающий эту задачу :)

Реализуйте функцию `calculateHanoi`, которая принимает параметры `diskNumber` и `turnsSpeed`. `diskNumber` — это число **дисков**, а `turnsSpeed` — скорость перемещения дисков (в **ходах** в **час**). Оба параметра являются числами (тип `number`)

Функция `calculateHanoi` возвращает объект с 2 свойствами:
* `turns` (минимальное число (тип `number`) ходов, необходимое для решения головоломки)
* `seconds` (минимальное число (тип `number`) **секунд**, необходимое для решения головоломки при заданной скорости; должно быть целым числом, полученным в результате округления результата расчетов в большую сторону)

Вам не нужно валидировать входные параметры.

Например:

`calculateHanoi(9, 4308) => { turns: 511, seconds: 427 }`

Решение в `src/hanoi-tower.js`.

---
### **Преобразование массива**

Ваша задача — реализовать функцию `transform(arr)`, которая принимает массив (тип `array`) и возвращает **преобразованный** массив, основываясь на **управляющих последовательностях**, которые содержит `arr`. **Управляющие последовательности** — это определенные строковые элементы вышеупомянутого массива:
* `--discard-next` исключает следующий за ней элемент исходного массива из преобразованного массива.
* `--discard-prev` исключает предшествующий ей элемент исходного массива из преобразованного массива.
* `--double-next` удваивает следующий за ней элемент исходного массива в преобразованном массиве.
* `--double-next` удваивает предшествующий ей элемент исходного массива в преобразованном массиве.

Например:

`transform([1, 2, 3, '--double-next', 4, 5])` => `[1, 2, 3, 4, 4, 5]`

`transform([1, 2, 3, '--discard-prev', 4, 5])` => `[1, 2, 4, 5]`

Функция не должна изменять исходный массив. Управляющие последовательности применяются **последовательно, слева направо**. Управляющие последовательности **не попадают** в преобразованный массив. Управляющие последовательности в исходном массиве не встречаются подряд (не следуют одна за другой). Если около управляющей последовательности **нет элемента**, к которому она может быть применена, **она не делает ничего**. Функция должна выбросить ошибку, если `arr` не является массивом. 

Напишите свой код в `src/transform-array.js`.

---
### **Чейнмейкер**
Ваша задача — реализовать объект `chainMaker`, который будет создавать цепочки. Оконченная цепочка это строка (тип `string`) и выглядит следующим образом: `'( value1 )~~( value2 )~~( value3 )'`.

`chainMaker` имееет несколько **методов** для создания цепочек и их модификации:
* `getLength` возвращает текущую длину цепи в виде числа;
* `addLink(value)` добавляет звено, содержащее строковое представление `value` к цепочке;
* `removeLink(position)` удаляет звено цепи, находящееся в заданном положении;
* `reverseChain` разворачивает цепь задом наперед;
* `finishChain` завершает цепь и **возвращает** ее.

Методы `addLink`, `reverseChain` и `removeLink` **чейнятся**, в то время как остальные – нет. Если `addLink` вызван без аргументов, он добавляет пустое звено (`'(  )'`) в цепочку. Если `removeLink` принимает **некорректную** позицию (например, не являющуюся числом, или дробное число, или ссылающуюся на несуществующее звено), он должен выбросить **ошибку**. После вызова метода `finishChain` существующая на данный момент цепь должна быть удалена, как и в случае, если была выброшена **ошибка**.

Например:

`chainMaker.addLink(1).addLink(2).addLink(3).finishChain()` => `'( 1 )~~( 2 )~~( 3 )'`

`chainMaker.addLink(1).addLink(2).removeLink(1).addLink(3).finishChain()` => `'( 2 )~~( 3 )'`

`chainMaker.addLink(1).addLink(2).reverseChain().addLink(3).finishChain()` => `'( 2 )~~( 1 )~~( 3 )'`

Решение в `src/simple-chain.js`.

---
### **Рекурсивный вычислитель глубины**
Ваша задача — реализовать класс `DepthCalculator` с методом `calculateDepth`, который принимает массив и возвращает его **глубину**.

Метод `calculateDepth` должен проходить полученный массив **рекурсивно**. Глубина **плоского** массива — 1. Метод должен корректно работать с массивами, не содержащими элементов или содержащими пустые массивы.

Например:

`const depthCalc = new DepthCalculator();`
`const { calculateDepth } = depthCalc;`

`calculateDepth([1, 2, 3, 4, 5])` => `1`

`calculateDepth([1, 2, 3, [4, 5]])` => `2`

`calculateDepth([[[]]])` => `3`

Решение в `src/recursive-depth.js`.

---
### **Расширенный повторитель**

Ваша задача — реализовать функцию `repeater(str, options)`.
Эта функция возвращает повторяющуюся **строку**, основываясь на заданных параметрах:
*	`str` это **строка**, которая будет повторена
*	`options` это **объект** опций, который содержит следующие свойства:
  -	`repeatTimes` устанавливает число повторений `str`
  - `separator` это строка, разделяющая повторения `str`
  - `addition` это дополнительная строка, которая будет добавлена после каждого повторения `str`
  - `additionRepeatTimes` устанавливает число повторений `addition`
  - `additionSeparator` это строка, разделяющая повторения `addition`

Параметры `str` и `addition` по умолчанию являются **строками**. В случае, если они другого типа, он должны быть преобразованы к строке.
 
Параметры `separator` и `additionSeparator` являются строками.

`repeatTimes` и `additionRepeatTimes` являются целыми числами (в случае отсутствия любого из них соответствующая строка не повторяется).

Единственный обязательный параметр — это `str`, остальные могут не быть переданы.
Значение `separator` по умолчанию это `'+'`. Значение `additionSeparator` по умолчанию это `'|'`.

Например: `repeater('STRING', { repeatTimes: 3, separator: '**', addition: 'PLUS', additionRepeatTimes: 3, additionSeparator: '00' })` => `'STRINGPLUS00PLUS00PLUS**STRINGPLUS00PLUS00PLUS**STRINGPLUS00PLUS00PLUS'`

Решение в `src/extended-repeater.js`.

---
